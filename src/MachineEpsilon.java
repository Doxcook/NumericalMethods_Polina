//из лекции: машинный эпсилон - наибольшая относительная погрешность округления (1+что-то)

public class MachineEpsilon {
    public static void main(String[] args) {

        // Определение машинного эпсилон для типа double
        double start1 = 5.0; // Исходное значение для сравнения
        double epsilonDouble = 1.0; // Начальное значение эпсилон

        // Цикл продолжается, пока прибавление epsilonDouble/2 не эквивалентно start1
        while (start1 + epsilonDouble / 2.0 != start1) {
            epsilonDouble /= 2.0; // Делим эпсилон на 2, пока не достигнем машинного эпсилон
        }
        // Вывод найденного значения машинного эпсилон для double
        System.out.println("Эпсилон для double = " + start1 + " : " + epsilonDouble);

///////////////////////////////////////////////////////////////////////////////

        // Определение машинного эпсилон для типа float
        float start2 = 1.0F; // Исходное значение для сравнения
        float epsilonFloat = 1.0F; // Начальное значение эпсилон

        // Цикл продолжается, пока прибавление epsilonFloat/2 не эквивалентно start2
        while (start2 + epsilonFloat / 2.0F != start2) {
            epsilonFloat /= 2.0F; // Делим эпсилон на 2, пока не достигнем машинного эпсилон
        }
        // Вывод найденного значения машинного эпсилон для float
        System.out.println("Эпсилон для float = " + start2 + " : " + epsilonFloat);







        // Пример определения минимального числа типа double, которое не округлится до 0
//        double epsilon1 = 1.0; // Начальное значение
//        while (epsilon1 / 2.0 != 0) { // Пока деление на 2 не приводит к 0
//            epsilon1 /= 2.0; // Продолжаем делить эпсилон на 2
//        }
//        System.out.println("Минимальное число, которое не округлится до 0: " + epsilon1);
    }
}
